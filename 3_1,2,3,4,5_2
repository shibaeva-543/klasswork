# -*- coding: utf8 -*-
import networkx as nx
import matplotlib.pyplot as plt

def dfs(A, U, i, N, pos): 
    U[i] = True
    j = 0
    while A[i][j] != -1: 
        if U[A[i][j]] == False:
            U[A[i][j]] = True
            N[pos][0] = i
            N[pos][1] = A[i][j] 
            pos += 1
            dfs(A, U, A[i][j], N, pos)
        j += 1
        
def bfs(Q, A, U, N, pos):
    while len(Q) > 0:
        U[Q[0]] = True 
        j = 0
        while A[Q[0]][j] != -1: 
            if U[A[i][j]] == False:
                Q.append(A[i][j])
                N[pos][0] = Q[0]
                N[pos][1] = A[Q[0]][j] 
                pos += 1
            j += 1
        Q.pop(0)
        
def deikstra(Q, A, U, L):
    while len(Q) > 0:
        U[Q[0]] = True 
        j = 0
        while A[Q[0]][j] != -1: 
            if U[A[i][j]] == False:
                Q.append(A[i][j])
                L[A[i][j]] = L[Q[0]] + 1 
            j += 1
        Q.pop(0)      

v = int(input()) # вводим кол-во вершин
n = int(input()) # вводим кол-во рёбер и изолированных вершин
G = nx.Graph()
i = 0
A = [[-1] * v] * v
U = [False] * v
N = [-1, -1] * n
pos = 0
while i < n:
    X = list(map(int, input().split()))
    if len(X) == 1: 
        G.add_node(X[0])
        i += 1
    elif len(X) == 2: 
        G.add_edge(X[0], X[1])
        i += 1
        j = 0
        while(A[X[0]][j] != -1):
            j += 1
        A[j] = X[1]
        j = 0
        while(A[X[1]][j] != -1):
            j += 1
        A[j] = X[0]        
    elif len(X) == 3: 
        G.add_edge(X[0], X[1], weight=X[2])
        i += 1
        j = 0
        while(A[X[0]][j] != -1):
            j += 1
        A[j] = X[1]
        j = 0
        while(A[X[1]][j] != -1):
            j += 1
        A[j] = X[0]           
    
nx.draw(G)
plt.savefig("simple_path.png")
plt.show() 


B = nx.connected_components(G)
if len(B) > 1:
    print('Connected')
else:
    print('Not connected')
print(B)

# DFS
flag = False
i = 0
pos = 0

while not flag:
    dfs(A, U, i, N, pos)
    t = 0
    while t < v or U[t] != False:
        t += 1
    if t == v:
        flag = True
        
g = nx.Graph(N)
nx.draw(g)

# BFS
Q = []
U = [False] * v
flag = False
i = 0
pos = 0

while not flag:
    Q.append(i)
    bfs(Q, A, U, N, pos)
    j = 0
    t = 0
    while t < v or U[t] != False:
        t += 1
    if t == v:
        flag = True
    else:
        i = t
        
g = nx.Graph(N)
nx.draw(g)

# Deikstra
Q = []
U = [False] * v
L = [-1] * v
i = int(input())
L[i] = 0
Q.append(i)
deikstra(Q, A, U, L)
print(L)
